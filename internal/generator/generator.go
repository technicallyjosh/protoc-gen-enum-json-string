package generator

import (
	"bytes"
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

type Config struct {
	Version string
}

type Generator struct {
	config Config
	plugin *protogen.Plugin
}

const header = `// Code generated by protoc-gen-enum-json-string v%s, DO NOT EDIT.
// source: %s

package %s

import "encoding/json"
`

const implementations = `
func (x %[1]s) MarshalJSON() ([]byte, error) {
	return json.Marshal(%[1]s_name[int32(x)])
}

func (x *%[1]s) UnmarshalJSON(b []byte) error {
	var val string
	err := json.Unmarshal(b, &val)
	if err != nil {
		return err
	}

	*x = %[1]s(%[1]s_value[val])
	return nil
}
`

func New(plugin *protogen.Plugin, config Config) *Generator {
	return &Generator{
		config: config,
		plugin: plugin,
	}
}

func (g *Generator) Run() error {
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}

		if len(file.Enums) == 0 {
			continue
		}

		prefix := file.GeneratedFilenamePrefix

		fileBuffer := bytes.Buffer{}

		_, err := fileBuffer.WriteString(fmt.Sprintf(header, g.config.Version, *file.Proto.Name, file.GoPackageName))
		if err != nil {
			return err
		}

		// Top scoped enums.
		for _, enum := range file.Enums {
			_, err := fileBuffer.WriteString(fmt.Sprintf(implementations, enum.GoIdent.GoName))
			if err != nil {
				return err
			}
		}

		// All other enums under messages.
		enums := getEnums(file.Messages)

		for _, enum := range enums {
			_, err := fileBuffer.WriteString(fmt.Sprintf(implementations, enum.GoIdent.GoName))
			if err != nil {
				return err
			}
		}

		outFile := g.plugin.NewGeneratedFile(prefix+".enum_json_string.go", file.GoImportPath)

		_, err = outFile.Write(fileBuffer.Bytes())
		return err
	}

	return nil
}

func getEnums(messages []*protogen.Message) []*protogen.Enum {
	var enums []*protogen.Enum

	for _, msg := range messages {
		if len(msg.Enums) > 0 {
			enums = append(enums, msg.Enums...)
		}

		if len(msg.Messages) > 0 {
			enums = append(enums, getEnums(msg.Messages)...)
		}
	}

	return enums
}
